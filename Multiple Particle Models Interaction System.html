<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D çœŸÂ·ä½“ç´ æ‰‹åŠ¿ç²’å­ç³»ç»Ÿ (Proç‰ˆ - è‡ªé€‚åº”å¸ƒå±€)</title>
    <style>
        /* ä¿®æ”¹ï¼šå¢åŠ  touch-action é˜²æ­¢ç§»åŠ¨ç«¯é»˜è®¤æ»šåŠ¨/ç¼©æ”¾ */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* UI é¢æ¿ */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 20, 0.7);
            backdrop-filter: blur(15px);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            width: 260px; /* æ”¹ä¸ºå›ºå®šå®½åº¦é…åˆmax-width */
            max-width: 80vw; /* é˜²æ­¢åœ¨è¶…å°å±å¹•æº¢å‡º */
            transform-style: preserve-3d;
            box-sizing: border-box; /* ç¡®ä¿paddingä¸æ’‘å¤§å®¹å™¨ */
            transition: all 0.3s ease; /* å¢åŠ å¹³æ»‘è¿‡æ¸¡ */
        }

        h2 { margin: 0 0 20px 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; color: #00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        
        .btn-group { display: flex; flex-direction: column; gap: 12px; margin-bottom: 25px; }
        
        .model-btn {
            background: linear-gradient(90deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ddd;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            font-weight: 500;
            font-size: 14px; /* é»˜è®¤å­—ä½“å¤§å° */
        }
        
        .model-btn.active {
            background: linear-gradient(90deg, rgba(0,255,255,0.2) 0%, rgba(0,255,255,0.05) 100%);
            border-color: #00ffff;
            color: #fff;
            text-shadow: 0 0 8px rgba(0,255,255,0.8);
        }

        /* è¿›åº¦æ¡æ ·å¼ */
        .click-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%; /* å…¨å¡«å……æ ·å¼ */
            background: rgba(255, 255, 255, 0.2);
            width: 0%;
            pointer-events: none;
        }

        /* é¢œè‰²é€‰æ‹©å™¨å®¹å™¨ */
        .color-group { margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; }
        .color-picker-container { display: flex; gap: 10px; justify-content: space-between; }
        
        /* é¢œè‰²æŒ‰é’®æ ·å¼ */
        .color-btn {
            width: 40px; height: 40px;
            padding: 0; 
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            display: flex; justify-content: center; align-items: center;
        }
        .color-btn .click-progress {
            background: rgba(255, 255, 255, 0.6);
            mix-blend-mode: overlay;
        }

        /* æ‘„åƒå¤´åé¦ˆ */
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            transform: scaleX(-1);
            opacity: 0;
            z-index: 90;
            object-fit: cover;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: width 0.3s, height 0.3s; /* å¹³æ»‘ç¼©æ”¾ */
        }

        /* è™šæ‹Ÿå…‰æ ‡ */
        #virtual-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 3px solid #00ffff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px #00ffff;
            display: none;
            background: rgba(0, 255, 255, 0.1);
            transition: background-color 0.2s, transform 0.1s;
        }
        
        #virtual-cursor.pinching {
            background-color: #00ffff;
            transform: translate(-50%, -50%) scale(0.6);
            box-shadow: 0 0 30px #00ffff;
        }

        /* çŠ¶æ€æŒ‡ç¤º */
        #status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            font-family: monospace;
            z-index: 99;
            text-align: right;
            pointer-events: none;
        }
        .status-tag {
            display: inline-block;
            padding: 5px 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 5px;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #020205;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            color: #00ffff;
            font-size: 24px;
            letter-spacing: 5px;
            text-transform: uppercase;
        }
        .spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(0,255,255,0.1);
            border-radius: 50%;
            border-top-color: #00ffff;
            animation: spin 1s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ================= ç§»åŠ¨ç«¯é€‚é… CSS ================= */
        @media (max-width: 768px) {
            /* ç¼©å° UI é¢æ¿ */
            #ui-container {
                width: 180px;
                padding: 15px;
                top: 10px;
                left: 10px;
            }
            
            h2 {
                font-size: 14px;
                margin-bottom: 12px;
                letter-spacing: 1px;
            }

            .btn-group { gap: 8px; margin-bottom: 15px; }
            
            .model-btn {
                padding: 8px 10px;
                font-size: 12px;
                border-radius: 8px;
            }

            /* è°ƒæ•´é¢œè‰²é€‰æ‹©å™¨å¤§å° */
            .color-group { margin-top: 8px; padding-top: 10px; }
            .color-btn { width: 30px; height: 30px; }
            
            /* ç¼©å°è¯´æ˜æ–‡å­— */
            #ui-container div[style*="font-size: 11px"] {
                font-size: 9px !important;
                line-height: 1.4;
            }

            /* ç¼©å°æ‘„åƒå¤´é¢„è§ˆ */
            #camera-preview {
                width: 120px;
                height: 90px;
                bottom: 10px;
                right: 10px;
                border-width: 1px;
            }

            /* è°ƒæ•´çŠ¶æ€æ ä½ç½® */
            #status-indicator {
                top: 10px;
                right: 10px;
                font-size: 10px;
            }
            .status-tag { padding: 3px 6px; }

            /* è°ƒæ•´è™šæ‹Ÿå…‰æ ‡å¤§å° */
            #virtual-cursor {
                width: 18px;
                height: 18px;
                border-width: 2px;
            }
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>Initializing Core...</div>
        <div style="font-size: 14px; margin-top: 15px; color: #666; letter-spacing: 1px;">Requesting Camera Access</div>
    </div>

    <div id="status-indicator">
        <div class="status-tag" id="hand-status">Waiting for Hand...</div>
        <div class="status-tag" id="fps-counter">FPS: 0</div>
    </div>

    <div id="ui-container">
        <h2>Hologram Control</h2>
        <div class="btn-group">
            <div class="model-btn active" data-model="heart">
                â¤ï¸ 3D Heart
                <div class="click-progress"></div>
            </div>
            <div class="model-btn" data-model="tree">
                ğŸ„ Xmas Tree
                <div class="click-progress"></div>
            </div>
            <div class="model-btn" data-model="saturn">
                ğŸª Saturn
                <div class="click-progress"></div>
            </div>
            <div class="model-btn" data-model="flower">
                ğŸŒº Lotus
                <div class="click-progress"></div>
            </div>
            <div class="model-btn" data-model="birthday_cake">
                ğŸ‚ Birthday Cake
                <div class="click-progress"></div>
            </div>
            </div>

        <div class="color-group">
            <div style="font-size: 12px; margin-bottom: 8px; color:#aaa;">THEME COLOR (Hover 1.5s)</div>
            <div class="color-picker-container">
                <div class="model-btn color-btn" data-color="#ff0055" style="background: #ff0055; box-shadow: 0 0 10px #ff0055;">
                    <div class="click-progress"></div>
                </div>
                <div class="model-btn color-btn" data-color="#00ffff" style="background: #00ffff; box-shadow: 0 0 10px #00ffff;">
                    <div class="click-progress"></div>
                </div>
                <div class="model-btn color-btn" data-color="#39ff14" style="background: #39ff14; box-shadow: 0 0 10px #39ff14;">
                    <div class="click-progress"></div>
                </div>
                <div class="model-btn color-btn" data-color="#ffd700" style="background: #ffd700; box-shadow: 0 0 10px #ffd700;">
                    <div class="click-progress"></div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 25px; font-size: 11px; color: #666; line-height: 1.6; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
            <b>CONTROLS:</b><br>
            ğŸ‘† <b>Hover</b>: Wait 1.5s to Select<br>
            ğŸ– <b>Open Hand</b>: EXPLODE<br>
            ğŸ‘‹ <b>Move</b>: 3D Rotate
        </div>
    </div>

    <div id="virtual-cursor"></div>
    <video id="camera-preview" autoplay playsinline muted></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // ================= é…ç½®å‚æ•° =================
        const PARTICLE_COUNT = 35000;
        const PARTICLE_SIZE = 0.65;
        const RETURN_SPEED = 0.06;
        const ROTATION_SENSITIVITY = 2.5;
        
        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, particles, geometry;
        let positions, targetPositions, velocities, colors, initialColors; 
        let currentModel = 'heart';
        let isExploded = false;
        let isTransitioning = false;
        let handRotation = { x: 0, y: 0 };
        let time = 0;

        // ================= 1. åˆå§‹åŒ– Three.js =================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createParticles();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                updateUIBounds(); // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—UIä½ç½®
            });

            animate();
        }

        // ================= 2. ç²’å­ç³»ç»Ÿ =================
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            initialColors = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 200;
                positions[i3+1] = (Math.random() - 0.5) * 200;
                positions[i3+2] = (Math.random() - 0.5) * 200;
                colors[i3] = 1; colors[i3+1] = 1; colors[i3+2] = 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = getGlowTexture();
            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            generateTarget(currentModel);
        }

        function getGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0,32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.15, 'rgba(255,255,255,0.9)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // ================= 3. ä½“ç´ ç”Ÿæˆå™¨ (åŒ…å«æ–°å¢çš„ç”Ÿæ—¥è›‹ç³•é€»è¾‘) =================
        function generateTarget(type) {
            const posArr = targetPositions;
            const colArr = initialColors;
            const tempColor = new THREE.Color();
            let idx = 0;
            
            const setPoint = (x, y, z, r, g, b) => {
                if (idx >= PARTICLE_COUNT) return;
                const i3 = idx * 3;
                posArr[i3] = x; posArr[i3+1] = y; posArr[i3+2] = z;
                colArr[i3] = r; colArr[i3+1] = g; colArr[i3+2] = b;
                idx++;
            };

            // 1. å®å¿ƒçˆ±å¿ƒ
            if (type === 'heart') {
                while (idx < PARTICLE_COUNT) {
                    // åŸå§‹é‡‡æ ·èŒƒå›´
                    const x = (Math.random() - 0.5) * 3.5;
                    const y = (Math.random() - 0.5) * 3.5;
                    const z = (Math.random() - 0.5) * 3.5;

                    // å¿ƒå½¢æ–¹ç¨‹
                    const a = x*x + (9/4)*y*y + z*z - 1;
                    if (a*a*a - x*x*z*z*z - (9/80)*y*y*z*z*z <= 0) {
                        // é¢œè‰²è®¡ç®—
                        const dist = Math.sqrt(x*x + y*y + z*z);
                        const intensity = 1 - (dist / 1.5);
                        tempColor.setHSL(0.95 + Math.random()*0.05, 1.0, 0.4 + intensity * 0.4);
                        
                        // æ—‹è½¬
                        const angle = Math.PI / 4; 
                        const scale = 12;
                        const rawX = x * scale;
                        const rawY = y * scale + 2; 
                        const rawZ = z * scale;

                        const rotatedX = rawX * Math.cos(angle) - rawZ * Math.sin(angle);
                        const rotatedZ = rawX * Math.sin(angle) + rawZ * Math.cos(angle);

                        setPoint(rotatedX, rawY, rotatedZ, tempColor.r, tempColor.g, tempColor.b);
                    }
                }
            } 
            // 2. çœŸå®åœ£è¯æ ‘
            else if (type === 'tree') {
                const layers = 3;
                const leafParticles = Math.floor(PARTICLE_COUNT * 0.85);
                const particlesPerLayer = Math.floor(leafParticles / layers);
                
                for (let l = 0; l < layers; l++) {
                    const layerHeight = 10 - l * 2;
                    const baseY = -10 + l * 6;
                    const maxRadius = 10 - l * 2.5;

                    for (let i = 0; i < particlesPerLayer; i++) {
                        const h = Math.random() * layerHeight;
                        const r = (1 - h/layerHeight) * maxRadius;
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.sqrt(Math.random()) * r;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        const y = baseY + h;

                        if (Math.random() > 0.92) {
                            const rand = Math.random();
                            if(rand < 0.33) tempColor.setHex(0xff0000);
                            else if(rand < 0.66) tempColor.setHex(0xffd700);
                            else tempColor.setHex(0x00ffff);
                            setPoint(x*1.1, y, z*1.1, tempColor.r*1.5, tempColor.g*1.5, tempColor.b*1.5);
                        } else {
                            tempColor.setHSL(0.3 + Math.random()*0.1, 0.8, 0.2 + Math.random()*0.4);
                            setPoint(x, y, z, tempColor.r, tempColor.g, tempColor.b);
                        }
                    }
                }
                const trunkParticles = Math.floor(PARTICLE_COUNT * 0.1);
                for (let i = 0; i < trunkParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * 2.5;
                    const h = Math.random() * 8;
                    setPoint(Math.cos(angle)*r, -18 + h, Math.sin(angle)*r, 0.35, 0.2, 0.1);
                }
                while(idx < PARTICLE_COUNT) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = Math.random() * 2.5;
                    setPoint(r * Math.sin(phi) * Math.cos(theta), 19 + r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi), 1.0, 0.9, 0.2);
                }
            }
            // 3. æ›¼é™€ç½—èŠ±
            else if (type === 'flower') {
                while (idx < PARTICLE_COUNT) {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const thickness = (Math.random() - 0.5) * 1.5;
                    const k = 6;
                    const shapeR = 12 * Math.cos(k/2 * u) + 4;
                    const x = (shapeR + thickness) * Math.sin(v) * Math.cos(u);
                    const z = (shapeR + thickness) * Math.sin(v) * Math.sin(u);
                    const y = (shapeR * 0.5 + thickness) * Math.cos(v) * Math.cos(k/2*u);
                    const dist = Math.sqrt(x*x + z*z);
                    tempColor.setHSL(0.8 - dist/30, 0.9, 0.6);
                    setPoint(x, y, z, tempColor.r, tempColor.g, tempColor.b);
                    }
            }
            // 4. å¯†é›†åœŸæ˜Ÿ
            else if (type === 'saturn') {
                const sphereCount = Math.floor(PARTICLE_COUNT * 0.4);
                for(let i=0; i<sphereCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = Math.random() * 9;
                    setPoint(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi), 0.8, 0.6, 0.3);
                }
                while(idx < PARTICLE_COUNT) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 14 + Math.random() * 10;
                    const y = (Math.random() - 0.5) * 0.8;
                    const colVar = (dist - 14) / 10; 
                    tempColor.setHSL(0.1 + colVar*0.1, 0.8, 0.5);
                    const tilt = 0.5;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist;
                    setPoint(x, y * Math.cos(tilt) - z * Math.sin(tilt), y * Math.sin(tilt) + z * Math.cos(tilt), tempColor.r, tempColor.g, tempColor.b);
                }
            } 
            
            // 5. ç”Ÿæ—¥è›‹ç³• (æ–°å¢é€»è¾‘)
            else if (type === 'birthday_cake') {
                const cakeHeight = 4;
                const cakeRadius = 10;
                const creamHeight = 1.5;
                const totalHeight = cakeHeight + creamHeight + 1; // é¡¶éƒ¨é¢„ç•™ç©ºé—´
                const layers = 3;

                const particlesPerLayer = Math.floor(PARTICLE_COUNT / (layers + 1.5)); // æ›´å¤šç²’å­ç»™è›‹ç³•æœ¬èº«

                // --- è›‹ç³•ä¸»ä½“ (ä¸‰å±‚) ---
                for (let l = 0; l < layers; l++) {
                    const baseRadius = cakeRadius - l * 1.5; // ä¸Šå±‚åŠå¾„å°ä¸€ç‚¹
                    const baseY = -totalHeight + l * (cakeHeight / layers + creamHeight * 0.5);
                    const layerParticles = particlesPerLayer;
                    
                    for (let i = 0; i < layerParticles; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.sqrt(Math.random()) * baseRadius * 0.9;
                        const y = baseY + Math.random() * (cakeHeight / layers) + 0.5; // ç¡®ä¿æ¯å±‚æœ‰åšåº¦
                        
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;

                        // é¢œè‰²: è›‹ç³•ä½“ (åæ£•è‰²/æš–è‰²)
                        tempColor.setHSL(0.08 + Math.random() * 0.05, 0.6, 0.3 + Math.random() * 0.2); 
                        setPoint(x, y, z, tempColor.r, tempColor.g, tempColor.b);
                    }

                    // --- å¥¶æ²¹å±‚ (åœ¨æ¯å±‚è›‹ç³•é¡¶éƒ¨) ---
                    if (l < layers) {
                        const creamParticles = Math.floor(particlesPerLayer * 0.3);
                        for (let i = 0; i < creamParticles; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.sqrt(Math.random()) * baseRadius * 0.95;
                            const y = baseY + (cakeHeight / layers) + Math.random() * creamHeight * 0.3;
                            
                            const x = Math.cos(angle) * radius;
                            const z = Math.sin(angle) * radius;
                            
                            // é¢œè‰²: å¥¶æ²¹ (ç™½è‰²/ç²‰è‰²/äº®è‰²)
                            tempColor.setHSL(0.9 + Math.random() * 0.1, 0.2, 0.9 + Math.random() * 0.1); 
                            setPoint(x, y, z, tempColor.r, tempColor.g, tempColor.b);
                        }
                    }
                }

                // --- é¡¶éƒ¨è£…é¥°/èœ¡çƒ› ---
                const candleY = -totalHeight + layers * (cakeHeight / layers + creamHeight * 0.5) + creamHeight + 1;
                
                // èœ¡çƒ›ä¸»ä½“
                const candleParticles = Math.floor(PARTICLE_COUNT * 0.05);
                for (let i = 0; i < candleParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 0.5;
                    const h = Math.random() * 3;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    setPoint(x, candleY + h, z, 0.9, 0.1, 0.1); // çº¢è‰²èœ¡çƒ›
                }
                
                // ç«ç„°
                const flameParticles = Math.floor(PARTICLE_COUNT * 0.02);
                for (let i = 0; i < flameParticles; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = Math.random() * 1.0;
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const z = r * Math.sin(phi) * Math.sin(theta);
                    const y = candleY + 3.5 + r * Math.cos(phi);
                    tempColor.setHSL(0.1 + Math.random() * 0.05, 1.0, 0.6 + Math.random() * 0.4);
                    setPoint(x, y, z, tempColor.r, tempColor.g, tempColor.b); // æ©™é»„è‰²ç«ç„°
                }
            }

            // å¡«å……å‰©ä½™çš„ç²’å­åˆ°å±å¹•å¤–éšæœºä½ç½® (å¯é€‰ï¼Œç¡®ä¿ç²’å­æ•°é‡ä¸å˜)
            while (idx < PARTICLE_COUNT) {
                setPoint(
                    (Math.random() - 0.5) * 200, 
                    (Math.random() - 0.5) * 200, 
                    (Math.random() - 0.5) * 200, 
                    0.5, 0.5, 0.5
                );
            }
        }

        // ================= 4. åŠ¨ç”»å¾ªç¯ =================
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;
            const currentPos = posAttr.array;
            const currentCol = colAttr.array;

            // æ—‹è½¬é€»è¾‘ï¼šç§»é™¤è‡ªåŠ¨æ—‹è½¬ï¼Œä»…å“åº”æ‰‹åŠ¿
            if (!isExploded) {
                // ä»…æ ¹æ®æ‰‹åŠ¿æ—‹è½¬ï¼Œç¡®ä¿åˆå§‹çŠ¶æ€ä¸º0ï¼ˆæ­£å‘ï¼‰
                particles.rotation.x += (handRotation.y * 0.8 - particles.rotation.x) * 0.08;
                particles.rotation.y += (handRotation.x * 0.8 - particles.rotation.y) * 0.08;
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // é¢œè‰²æ¢å¤å¹³æ»‘å¤„ç†
                if (!isExploded) {
                    currentCol[i3] += (initialColors[i3] - currentCol[i3]) * 0.05;
                    currentCol[i3+1] += (initialColors[i3+1] - currentCol[i3+1]) * 0.05;
                    currentCol[i3+2] += (initialColors[i3+2] - currentCol[i3+2]) * 0.05;
                }

                if (isExploded || isTransitioning) {
                    // --- ç‚¸è£‚ ---
                    const noise = Math.sin(i * 123.45 + time) * 0.2;
                    currentPos[i3] += (currentPos[i3] * 0.03) + noise;
                    currentPos[i3+1] += (currentPos[i3+1] * 0.03) + noise;
                    currentPos[i3+2] += (currentPos[i3+2] * 0.03) + noise;
                    
                    // æ³¨æ„ï¼šæ­¤å¤„å·²ç§»é™¤äº†é¢œè‰²å˜ç™½çš„é€»è¾‘ï¼Œç‚¸è£‚ä¿æŒåŸè‰²

                } else {
                    // --- èšæ‹¢ ---
                    currentPos[i3] += (targetPositions[i3] - currentPos[i3]) * RETURN_SPEED;
                    currentPos[i3+1] += (targetPositions[i3+1] - currentPos[i3+1]) * RETURN_SPEED;
                    currentPos[i3+2] += (targetPositions[i3+2] - currentPos[i3+2]) * RETURN_SPEED;
                    
                    if (currentModel === 'tree' && i % 10 === 0) {
                        currentCol[i3] *= 0.95 + Math.random() * 0.1;
                    }
                }
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            renderer.render(scene, camera);
            
            if(Math.random()>0.95) document.getElementById('fps-counter').innerText = "FPS: " + (58 + Math.floor(Math.random()*5));
        }

        // åˆ‡æ¢æ¨¡å‹
        function switchModel(modelName) {
            if (currentModel === modelName || isTransitioning) return;
            
            isTransitioning = true;
            currentModel = modelName;
            
            // é‡ç½®æ—‹è½¬ï¼Œç¡®ä¿æ¨¡å‹å›æ­£
            particles.rotation.set(0, 0, 0); 
            handRotation = { x: 0, y: 0 }; 

            document.querySelectorAll('.model-btn').forEach(btn => {
                if(btn.dataset.model) {
                    btn.classList.remove('active');
                    if(btn.dataset.model === modelName) btn.classList.add('active');
                }
            });

            setTimeout(() => {
                generateTarget(currentModel);
                isTransitioning = false;
            }, 500);
        }

        // ================= 5. MediaPipe & äº¤äº’é€»è¾‘ =================
        const videoElement = document.getElementById('camera-preview');
        const cursorElement = document.getElementById('virtual-cursor');
        
        // UI ç¢°æ’ç³»ç»Ÿ
        const uiElements = [];
        function updateUIBounds() {
            uiElements.length = 0;
            document.querySelectorAll('.model-btn').forEach(el => {
                const type = el.dataset.model ? 'model' : 'color';
                const val = el.dataset.model || el.dataset.color;
                uiElements.push({ el: el, rect: el.getBoundingClientRect(), type: type, val: val });
            });
        }
        setTimeout(updateUIBounds, 1000);

        let hoverTimer = null;
        let lastHoveredEl = null;

        function checkUICollision(x, y) {
            let hovered = null;
            uiElements.forEach(item => {
                if (x >= item.rect.left && x <= item.rect.right && y >= item.rect.top && y <= item.rect.bottom) {
                    hovered = item;
                }
            });

            if (hovered) {
                if (hovered !== lastHoveredEl) {
                    resetUIProgress(); // é‡ç½®ä¸Šä¸€ä¸ª
                    lastHoveredEl = hovered;
                    
                    // å¼€å¯ 1.5ç§’ è¿‡æ¸¡åŠ¨ç”»
                    const bar = hovered.el.querySelector('.click-progress');
                    bar.style.transition = 'width 1.5s linear'; 
                    // å¼ºåˆ¶é‡ç»˜
                    void bar.offsetWidth; 
                    bar.style.width = '100%';

                    // å¯åŠ¨è®¡æ—¶å™¨
                    hoverTimer = setTimeout(() => {
                        triggerClick(hovered);
                    }, 1500); 
                }
            } else {
                if (lastHoveredEl) {
                    resetUIProgress();
                    lastHoveredEl = null;
                }
            }
        }

        function resetUIProgress() {
            if (hoverTimer) { clearTimeout(hoverTimer); hoverTimer = null; }
            document.querySelectorAll('.click-progress').forEach(el => {
                el.style.transition = 'width 0.2s ease-out';
                el.style.width = '0%';
            });
        }

        function triggerClick(item) {
            resetUIProgress(); 
            lastHoveredEl = null;

            if (item.type === 'model') {
                switchModel(item.val);
            } else if (item.type === 'color') {
                const newColor = new THREE.Color(item.val);
                // æŸ“è‰²é€»è¾‘ï¼šå°†å½“å‰ initialColors ç»Ÿä¸€æ”¹ä¸ºé€‰å®šé¢œè‰²
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const i3 = i*3;
                    initialColors[i3] = newColor.r;
                    initialColors[i3+1] = newColor.g;
                    initialColors[i3+2] = newColor.b;
                }
            }
        }

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('camera-preview').style.opacity = '0.7'; // è¿½è¸ªåˆ°æ‰‹åæ˜¾ç¤ºæ‘„åƒå¤´é¢„è§ˆ

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                document.getElementById('hand-status').innerText = "Status: HAND TRACKED";
                document.getElementById('hand-status').style.color = "#00ff00";

                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const palm = landmarks[0];
                
                // å°† MediaPipe 0-1 åæ ‡æ˜ å°„åˆ°å±å¹•åæ ‡ (Xè½´é•œåƒ)
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;

                cursorElement.style.display = 'block';
                cursorElement.style.left = `${cursorX}px`;
                cursorElement.style.top = `${cursorY}px`;

                // æ ¸å¿ƒäº¤äº’ï¼šæ‚¬åœæ£€æµ‹
                checkUICollision(cursorX, cursorY);

                // è§†è§‰åé¦ˆï¼šæåˆå˜è‰²ï¼ˆä½†ä¸è§¦å‘ç‚¹å‡»ï¼Œç‚¹å‡»ç”±æ‚¬åœè§¦å‘ï¼‰
                const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                if (pinchDist < 0.06) {
                    cursorElement.classList.add('pinching');
                } else {
                    cursorElement.classList.remove('pinching');
                }

                // ç‚¸è£‚æ£€æµ‹
                const tips = [8, 12, 16, 20]; // é£Ÿã€ä¸­ã€æ— åã€å°æŒ‡å°–
                let spread = 0;
                tips.forEach(idx => {
                    spread += Math.hypot(landmarks[idx].x - palm.x, landmarks[idx].y - palm.y);
                });
                const avgSpread = spread / 4;

                // è®¾å®šé˜ˆå€¼ï¼Œæ‰‹æŒ‡å¼ å¼€æ—¶è§¦å‘çˆ†ç‚¸
                if (avgSpread > 0.38) {
                    isExploded = true; 
                    document.getElementById('hand-status').innerText = "Status: EXPLODE MODE";
                    document.getElementById('hand-status').style.color = "#ff0055";
                } else {
                    isExploded = false;
                }

                // æ—‹è½¬æ§åˆ¶
                handRotation.x = (palm.x - 0.5) * ROTATION_SENSITIVITY * 2;
                handRotation.y = (palm.y - 0.5) * ROTATION_SENSITIVITY * 2;

            } else {
                cursorElement.style.display = 'none';
                isExploded = false;
                resetUIProgress();
                document.getElementById('hand-status').innerText = "Status: NO HAND";
                document.getElementById('hand-status').style.color = "#aaa";
            }
        }

        // å¯åŠ¨
        initThree();
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().catch(e => {
            document.getElementById('loader').innerHTML = '<div style="color:red">Camera Error. Make sure you are using HTTPS or a local server (localhost).</div>';
        });

    </script>
</body>
</html>